"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/chart-utils.ts":
/*!****************************!*\
  !*** ./lib/chart-utils.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXCHANGE_COLORS: function() { return /* binding */ EXCHANGE_COLORS; },\n/* harmony export */   createStepData: function() { return /* binding */ createStepData; },\n/* harmony export */   formatCumulativeFees: function() { return /* binding */ formatCumulativeFees; },\n/* harmony export */   formatFee: function() { return /* binding */ formatFee; },\n/* harmony export */   formatVolume: function() { return /* binding */ formatVolume; },\n/* harmony export */   generateBpsTicks: function() { return /* binding */ generateBpsTicks; },\n/* harmony export */   generateTicks: function() { return /* binding */ generateTicks; },\n/* harmony export */   snapToMillionTick: function() { return /* binding */ snapToMillionTick; }\n/* harmony export */ });\nfunction formatVolume(volume) {\n    // Volume is stored in millions format (e.g., 5 = $5M)\n    if (volume >= 1000) {\n        return \"$\".concat((volume / 1000).toFixed(1), \"B\");\n    } else if (volume >= 1) {\n        return \"$\".concat(volume.toFixed(1), \"M\");\n    } else {\n        return \"$\".concat((volume * 1000).toFixed(0), \"K\");\n    }\n}\nfunction formatFee(fee) {\n    return \"\".concat(fee >= 0 ? \"+\" : \"\").concat(fee.toFixed(1), \"bps\");\n}\nfunction formatCumulativeFees(fees) {\n    // Format as full dollar amount with commas and 2 decimal places\n    return \"$\".concat(fees.toLocaleString(\"en-US\", {\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }));\n}\nfunction generateTicks(min, max, isLog) {\n    if (isLog) {\n        // For log scale, generate powers of 10\n        const minLog = Math.floor(Math.log10(Math.max(1, 1)));\n        const maxLog = Math.ceil(Math.log10(max));\n        const ticks = [];\n        for(let i = minLog; i <= maxLog; i++){\n            const base = Math.pow(10, i);\n            ticks.push(base);\n            if (base * 5 <= max) ticks.push(base * 5);\n        }\n        return ticks.filter((tick)=>tick >= 1 && tick <= max);\n    } else {\n        // For linear scale, generate clean ticks in millions format\n        const range = max - min;\n        let tickInterval;\n        // Use clean intervals based on range (values are in millions)\n        if (range <= 20) {\n            tickInterval = 5; // $5M intervals\n        } else if (range <= 100) {\n            tickInterval = 10; // $10M intervals\n        } else if (range <= 500) {\n            tickInterval = 50; // $50M intervals\n        } else if (range <= 2000) {\n            tickInterval = 100; // $100M intervals\n        } else if (range <= 5000) {\n            tickInterval = 500; // $500M intervals\n        } else {\n            tickInterval = 1000; // $1B intervals\n        }\n        // Start from 0 or first clean interval\n        const startTick = Math.max(0, Math.floor(min / tickInterval) * tickInterval);\n        const endTick = Math.ceil(max / tickInterval) * tickInterval;\n        const ticks = [];\n        for(let tick = startTick; tick <= endTick; tick += tickInterval){\n            if (tick >= min && tick <= max) {\n                ticks.push(tick);\n            }\n        }\n        // Ensure we always have at least a few ticks\n        if (ticks.length < 3) {\n            const smallerInterval = tickInterval / 2;\n            const newTicks = [];\n            for(let tick = startTick; tick <= endTick; tick += smallerInterval){\n                if (tick >= min && tick <= max) {\n                    newTicks.push(tick);\n                }\n            }\n            return newTicks;\n        }\n        return ticks;\n    }\n}\nfunction generateBpsTicks(min, max) {\n    // Generate ticks every 1 basis point\n    const minTick = Math.floor(min);\n    const maxTick = Math.ceil(max);\n    const ticks = [];\n    for(let tick = minTick; tick <= maxTick; tick += 1){\n        ticks.push(tick);\n    }\n    return ticks;\n}\nfunction snapToMillionTick(volume) {\n    // Don't snap - return the exact volume for precise alignment\n    return Math.round(volume);\n}\nfunction createStepData(feeSchedule, maxVolume) {\n    const stepData = [];\n    for(let i = 0; i < feeSchedule.length; i++){\n        const current = feeSchedule[i];\n        const next = feeSchedule[i + 1];\n        // Add the step start point\n        stepData.push({\n            volume: current.volume,\n            fee: current.fee\n        });\n        // Add the step end point (right before next volume)\n        if (next) {\n            stepData.push({\n                volume: next.volume - 1,\n                fee: current.fee\n            });\n        } else {\n            // Last step extends to max volume\n            stepData.push({\n                volume: maxVolume,\n                fee: current.fee\n            });\n        }\n    }\n    return stepData;\n}\nconst EXCHANGE_COLORS = {\n    \"Binance\": \"#F0B90B\",\n    \"Bybit\": \"#F7931A\",\n    \"Kraken\": \"#5C4B99\",\n    \"OKX\": \"#0066CC\",\n    \"Coinbase\": \"#0052FF\",\n    \"Hyperliquid\": \"#00D2FF\",\n    \"EdgeX\": \"#FF6B35\",\n    \"Jupiter\": \"#C147E9\",\n    \"Drift\": \"#9945FF\",\n    \"ApeX Protocol\": \"#00FFB3\",\n    \"Aster\": \"#FF4081\",\n    \"GMX\": \"#4DABF7\",\n    \"Vertex\": \"#7C3AED\",\n    \"ParaDex\": \"#10B981\",\n    \"Nado\": \"#FF1744\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVF3QztnQkFBV3JDLEtBQUt1QyxRQUFRdkMsR0FBRztZQUFDO1FBQ3REO0lBQ0Y7SUFFQSxPQUFPc0M7QUFDVDtBQUVPLE1BQU1HLGtCQUFrQjtJQUM3QixXQUFXO0lBQ1gsU0FBUztJQUNULFVBQVU7SUFDVixPQUFPO0lBQ1AsWUFBWTtJQUNaLGVBQWU7SUFDZixTQUFTO0lBQ1QsV0FBVztJQUNYLFNBQVM7SUFDVCxpQkFBaUI7SUFDakIsU0FBUztJQUNULE9BQU87SUFDUCxVQUFVO0lBQ1YsV0FBVztJQUNYLFFBQVE7QUFDVixFQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9jaGFydC11dGlscy50cz9kYjllIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBmb3JtYXRWb2x1bWUodm9sdW1lOiBudW1iZXIpOiBzdHJpbmcge1xuICAvLyBWb2x1bWUgaXMgc3RvcmVkIGluIG1pbGxpb25zIGZvcm1hdCAoZS5nLiwgNSA9ICQ1TSlcbiAgaWYgKHZvbHVtZSA+PSAxMDAwKSB7XG4gICAgcmV0dXJuIGAkJHsodm9sdW1lIC8gMTAwMCkudG9GaXhlZCgxKX1CYDtcbiAgfSBlbHNlIGlmICh2b2x1bWUgPj0gMSkge1xuICAgIHJldHVybiBgJCR7dm9sdW1lLnRvRml4ZWQoMSl9TWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAkJHsodm9sdW1lICogMTAwMCkudG9GaXhlZCgwKX1LYDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RmVlKGZlZTogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2ZlZSA+PSAwID8gJysnIDogJyd9JHtmZWUudG9GaXhlZCgxKX1icHNgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Q3VtdWxhdGl2ZUZlZXMoZmVlczogbnVtYmVyKTogc3RyaW5nIHtcbiAgLy8gRm9ybWF0IGFzIGZ1bGwgZG9sbGFyIGFtb3VudCB3aXRoIGNvbW1hcyBhbmQgMiBkZWNpbWFsIHBsYWNlc1xuICByZXR1cm4gYCQke2ZlZXMudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywge1xuICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDJcbiAgfSl9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVGlja3MobWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBpc0xvZzogYm9vbGVhbik6IG51bWJlcltdIHtcbiAgaWYgKGlzTG9nKSB7XG4gICAgLy8gRm9yIGxvZyBzY2FsZSwgZ2VuZXJhdGUgcG93ZXJzIG9mIDEwXG4gICAgY29uc3QgbWluTG9nID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE1hdGgubWF4KDEsIDEpKSk7XG4gICAgY29uc3QgbWF4TG9nID0gTWF0aC5jZWlsKE1hdGgubG9nMTAobWF4KSk7XG4gICAgY29uc3QgdGlja3M6IG51bWJlcltdID0gW107XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IG1pbkxvZzsgaSA8PSBtYXhMb2c7IGkrKykge1xuICAgICAgY29uc3QgYmFzZSA9IE1hdGgucG93KDEwLCBpKTtcbiAgICAgIHRpY2tzLnB1c2goYmFzZSk7XG4gICAgICBpZiAoYmFzZSAqIDUgPD0gbWF4KSB0aWNrcy5wdXNoKGJhc2UgKiA1KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRpY2tzLmZpbHRlcih0aWNrID0+IHRpY2sgPj0gMSAmJiB0aWNrIDw9IG1heCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRm9yIGxpbmVhciBzY2FsZSwgZ2VuZXJhdGUgY2xlYW4gdGlja3MgaW4gbWlsbGlvbnMgZm9ybWF0XG4gICAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgbGV0IHRpY2tJbnRlcnZhbDogbnVtYmVyO1xuICAgIFxuICAgIC8vIFVzZSBjbGVhbiBpbnRlcnZhbHMgYmFzZWQgb24gcmFuZ2UgKHZhbHVlcyBhcmUgaW4gbWlsbGlvbnMpXG4gICAgaWYgKHJhbmdlIDw9IDIwKSB7IC8vIDw9ICQyME1cbiAgICAgIHRpY2tJbnRlcnZhbCA9IDU7IC8vICQ1TSBpbnRlcnZhbHNcbiAgICB9IGVsc2UgaWYgKHJhbmdlIDw9IDEwMCkgeyAvLyA8PSAkMTAwTVxuICAgICAgdGlja0ludGVydmFsID0gMTA7IC8vICQxME0gaW50ZXJ2YWxzXG4gICAgfSBlbHNlIGlmIChyYW5nZSA8PSA1MDApIHsgLy8gPD0gJDUwME1cbiAgICAgIHRpY2tJbnRlcnZhbCA9IDUwOyAvLyAkNTBNIGludGVydmFsc1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPD0gMjAwMCkgeyAvLyA8PSAkMkJcbiAgICAgIHRpY2tJbnRlcnZhbCA9IDEwMDsgLy8gJDEwME0gaW50ZXJ2YWxzXG4gICAgfSBlbHNlIGlmIChyYW5nZSA8PSA1MDAwKSB7IC8vIDw9ICQ1QlxuICAgICAgdGlja0ludGVydmFsID0gNTAwOyAvLyAkNTAwTSBpbnRlcnZhbHNcbiAgICB9IGVsc2Uge1xuICAgICAgdGlja0ludGVydmFsID0gMTAwMDsgLy8gJDFCIGludGVydmFsc1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGFydCBmcm9tIDAgb3IgZmlyc3QgY2xlYW4gaW50ZXJ2YWxcbiAgICBjb25zdCBzdGFydFRpY2sgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKG1pbiAvIHRpY2tJbnRlcnZhbCkgKiB0aWNrSW50ZXJ2YWwpO1xuICAgIGNvbnN0IGVuZFRpY2sgPSBNYXRoLmNlaWwobWF4IC8gdGlja0ludGVydmFsKSAqIHRpY2tJbnRlcnZhbDtcbiAgICBcbiAgICBjb25zdCB0aWNrczogbnVtYmVyW10gPSBbXTtcbiAgICBmb3IgKGxldCB0aWNrID0gc3RhcnRUaWNrOyB0aWNrIDw9IGVuZFRpY2s7IHRpY2sgKz0gdGlja0ludGVydmFsKSB7XG4gICAgICBpZiAodGljayA+PSBtaW4gJiYgdGljayA8PSBtYXgpIHtcbiAgICAgICAgdGlja3MucHVzaCh0aWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGF0IGxlYXN0IGEgZmV3IHRpY2tzXG4gICAgaWYgKHRpY2tzLmxlbmd0aCA8IDMpIHtcbiAgICAgIGNvbnN0IHNtYWxsZXJJbnRlcnZhbCA9IHRpY2tJbnRlcnZhbCAvIDI7XG4gICAgICBjb25zdCBuZXdUaWNrczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGZvciAobGV0IHRpY2sgPSBzdGFydFRpY2s7IHRpY2sgPD0gZW5kVGljazsgdGljayArPSBzbWFsbGVySW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKHRpY2sgPj0gbWluICYmIHRpY2sgPD0gbWF4KSB7XG4gICAgICAgICAgbmV3VGlja3MucHVzaCh0aWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1RpY2tzO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQnBzVGlja3MobWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAvLyBHZW5lcmF0ZSB0aWNrcyBldmVyeSAxIGJhc2lzIHBvaW50XG4gIGNvbnN0IG1pblRpY2sgPSBNYXRoLmZsb29yKG1pbik7XG4gIGNvbnN0IG1heFRpY2sgPSBNYXRoLmNlaWwobWF4KTtcbiAgXG4gIGNvbnN0IHRpY2tzOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCB0aWNrID0gbWluVGljazsgdGljayA8PSBtYXhUaWNrOyB0aWNrICs9IDEpIHtcbiAgICB0aWNrcy5wdXNoKHRpY2spO1xuICB9XG4gIFxuICByZXR1cm4gdGlja3M7XG59XG5leHBvcnQgZnVuY3Rpb24gc25hcFRvTWlsbGlvblRpY2sodm9sdW1lOiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBEb24ndCBzbmFwIC0gcmV0dXJuIHRoZSBleGFjdCB2b2x1bWUgZm9yIHByZWNpc2UgYWxpZ25tZW50XG4gIHJldHVybiBNYXRoLnJvdW5kKHZvbHVtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGVwRGF0YShcbiAgZmVlU2NoZWR1bGU6IHsgdm9sdW1lOiBudW1iZXI7IGZlZTogbnVtYmVyIH1bXSxcbiAgbWF4Vm9sdW1lOiBudW1iZXJcbik6IHsgdm9sdW1lOiBudW1iZXI7IGZlZTogbnVtYmVyIH1bXSB7XG4gIGNvbnN0IHN0ZXBEYXRhOiB7IHZvbHVtZTogbnVtYmVyOyBmZWU6IG51bWJlciB9W10gPSBbXTtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmVlU2NoZWR1bGUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50ID0gZmVlU2NoZWR1bGVbaV07XG4gICAgY29uc3QgbmV4dCA9IGZlZVNjaGVkdWxlW2kgKyAxXTtcbiAgICBcbiAgICAvLyBBZGQgdGhlIHN0ZXAgc3RhcnQgcG9pbnRcbiAgICBzdGVwRGF0YS5wdXNoKHsgdm9sdW1lOiBjdXJyZW50LnZvbHVtZSwgZmVlOiBjdXJyZW50LmZlZSB9KTtcbiAgICBcbiAgICAvLyBBZGQgdGhlIHN0ZXAgZW5kIHBvaW50IChyaWdodCBiZWZvcmUgbmV4dCB2b2x1bWUpXG4gICAgaWYgKG5leHQpIHtcbiAgICAgIHN0ZXBEYXRhLnB1c2goeyB2b2x1bWU6IG5leHQudm9sdW1lIC0gMSwgZmVlOiBjdXJyZW50LmZlZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGFzdCBzdGVwIGV4dGVuZHMgdG8gbWF4IHZvbHVtZVxuICAgICAgc3RlcERhdGEucHVzaCh7IHZvbHVtZTogbWF4Vm9sdW1lLCBmZWU6IGN1cnJlbnQuZmVlIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHN0ZXBEYXRhO1xufVxuXG5leHBvcnQgY29uc3QgRVhDSEFOR0VfQ09MT1JTID0ge1xuICAnQmluYW5jZSc6ICcjRjBCOTBCJyxcbiAgJ0J5Yml0JzogJyNGNzkzMUEnLFxuICAnS3Jha2VuJzogJyM1QzRCOTknLFxuICAnT0tYJzogJyMwMDY2Q0MnLFxuICAnQ29pbmJhc2UnOiAnIzAwNTJGRicsXG4gICdIeXBlcmxpcXVpZCc6ICcjMDBEMkZGJyxcbiAgJ0VkZ2VYJzogJyNGRjZCMzUnLFxuICAnSnVwaXRlcic6ICcjQzE0N0U5JyxcbiAgJ0RyaWZ0JzogJyM5OTQ1RkYnLFxuICAnQXBlWCBQcm90b2NvbCc6ICcjMDBGRkIzJyxcbiAgJ0FzdGVyJzogJyNGRjQwODEnLFxuICAnR01YJzogJyM0REFCRjcnLFxuICAnVmVydGV4JzogJyM3QzNBRUQnLFxuICAnUGFyYURleCc6ICcjMTBCOTgxJyxcbiAgJ05hZG8nOiAnI0ZGMTc0NCcsXG59IGFzIGNvbnN0OyJdLCJuYW1lcyI6WyJmb3JtYXRWb2x1bWUiLCJ2b2x1bWUiLCJ0b0ZpeGVkIiwiZm9ybWF0RmVlIiwiZmVlIiwiZm9ybWF0Q3VtdWxhdGl2ZUZlZXMiLCJmZWVzIiwidG9Mb2NhbGVTdHJpbmciLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJnZW5lcmF0ZVRpY2tzIiwibWluIiwibWF4IiwiaXNMb2ciLCJtaW5Mb2ciLCJNYXRoIiwiZmxvb3IiLCJsb2cxMCIsIm1heExvZyIsImNlaWwiLCJ0aWNrcyIsImkiLCJiYXNlIiwicG93IiwicHVzaCIsImZpbHRlciIsInRpY2siLCJyYW5nZSIsInRpY2tJbnRlcnZhbCIsInN0YXJ0VGljayIsImVuZFRpY2siLCJsZW5ndGgiLCJzbWFsbGVySW50ZXJ2YWwiLCJuZXdUaWNrcyIsImdlbmVyYXRlQnBzVGlja3MiLCJtaW5UaWNrIiwibWF4VGljayIsInNuYXBUb01pbGxpb25UaWNrIiwicm91bmQiLCJjcmVhdGVTdGVwRGF0YSIsImZlZVNjaGVkdWxlIiwibWF4Vm9sdW1lIiwic3RlcERhdGEiLCJjdXJyZW50IiwibmV4dCIsIkVYQ0hBTkdFX0NPTE9SUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/chart-utils.ts\n"));

/***/ })

});